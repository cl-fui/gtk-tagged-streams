(in-package :gtk-tagged-streams)
;;=============================================================================
;; tag-only-in-stream
;;
;; It is often useful to input user text from a GTK text buffer, without
;; confusing it with text generated by the appliction.  This stream is an input
;; stream that ignores all text except the text tagged with a specified tag.
;

(defclass tag-only-in-stream
    (buffer-tag-stream trivial-gray-streams:fundamental-character-input-stream)
  ())


(defun tois-prep-iter (stream)
  "if the iter is not in a tag, advance; return nil if eof"
  (with-slots (buffer iter mark tag) stream
    (%gtb-get-iter-at-mark buffer iter mark); current position
    (or (gti-has-tag iter tag)
      (gti-forward-to-tag-toggle iter tag))))
;;===========================================================================
(defmethod trivial-gray-streams:stream-read-char
    ((stream tag-only-in-stream))
  (if (tois-prep-iter stream)
      (with-slots (buffer iter mark) stream
	(prog1
	    (gti-get-char iter)
	  (gti-forward-char iter)
	  (gtb-move-mark buffer mark iter)))
      :eof))

;;===========================================================================
(defmethod trivial-gray-streams:stream-peek-char
    ((stream tag-only-in-stream))
   (if (tois-prep-iter stream)
       (gti-get-char (iter stream))
       :eof))
;;===========================================================================
;; unread-char
;;
;; Pay attention: although backing up is technically wrong, next read will
;; read the correct character...  Can't count on position being same as
;; before.
(defmethod trivial-gray-streams:stream-unread-char
    ((stream tag-only-in-stream) char)
  (with-slots (buffer iter mark) stream
    (prognil
      (%gtb-get-iter-at-mark buffer iter mark); current position
      (gti-backward-char iter)
      (gtb-move-mark buffer mark iter))))

